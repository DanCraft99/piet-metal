extern crate proc_macro;
#[macro_use]
extern crate quote;

use std::fmt::Write;

use proc_macro::TokenStream;
use syn::{parse::Parse, parse::ParseStream, parse_macro_input, spanned::Spanned};
use syn::{Data, Expr, ExprLit, Fields, FieldsNamed, Ident, ItemStruct, Lit, TypeArray, TypePath};

// Probably don't need this, will use ItemMod instead.
#[derive(Debug)]
struct Items(Vec<syn::Item>);

fn ident_str(ident: &Option<Ident>) -> String {
    if let Some(ident) = ident {
        ident.to_string()
    } else {
        "_".to_string()
    }
}

fn expr_int_lit(e: &Expr) -> Option<i64> {
    if let Expr::Lit(ExprLit { lit: Lit::Int(lit_int), .. }) = e {
        lit_int.base10_parse().ok()
    } else {
        None
    }
}

fn scalar_ty_to_metal(ty: &syn::Type) -> Option<&'static str> {
    match ty {
        syn::Type::Path(TypePath {
            path: syn::Path { segments, .. },
            ..
        }) => {
            if segments.len() == 1 {
                match segments[0].ident.to_string().as_str() {
                    "f32" => "float".into(),
                    "i8" => "char".into(),
                    "i16" => "short".into(),
                    "i32" => "int".into(),
                    "u8" => "uchar".into(),
                    "u16" => "ushort".into(),
                    "u32" => "uint".into(),
                    _ => None,
                }
            } else {
                None
            }
        }
        _ => None,
    }
}

// Convert Rust type to equivalent Metal
fn ty_to_metal(ty: &syn::Type) -> String {
    if let Some(scalar) = scalar_ty_to_metal(ty) {
        return scalar.to_string();
    }
    match ty {
        syn::Type::Path(TypePath {
            path: syn::Path { segments, .. },
            ..
        }) => {
            if segments.len() == 1 {
                match segments[0].ident.to_string().as_str() {
                    ty => panic!("can't convert rust type {}", ty),
                }
            } else {
                panic!("can't handle multiple segments");
            }
        }
        syn::Type::Array(TypeArray {
            elem, len, ..
        }) => {
            if let Some(elem) = scalar_ty_to_metal(&elem) {
                if let Some(len) = expr_int_lit(len) {
                    // maybe sanity-check length here
                    format!("{}{}", elem, len)
                } else {
                    panic!("can't deal with variable length scalar arrays");
                }
            } else {
                panic!("can't deal with non-scalar arrays");
            }
        }
        _ => panic!("unknown type"),
    }
}

fn metal_struct(item: &syn::Item) -> Result<String, syn::Error> {
    let mut result = String::new();
    match item {
        syn::Item::Struct(ItemStruct {
            ident,
            fields: Fields::Named(FieldsNamed { named, .. }),
            ..
        }) => {
            write!(&mut result, "struct {} {{\n", ident).unwrap();
            println!("struct {}: {:#?}", ident, named);
            for field in named {
                write!(
                    &mut result,
                    "    {}: {};\n",
                    ident_str(&field.ident),
                    ty_to_metal(&field.ty)
                )
                .unwrap();
            }
            write!(&mut result, "}}\n").unwrap();
        }
        // TODO: return error here
        _ => panic!("unknown item"),
    }
    Ok(result)
}

#[proc_macro]
pub fn piet_metal(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as syn::ItemMod);
    //println!("input: {:#?}", input);
    let gen_metal_fn = format_ident!("gen_metal_{}", input.ident);
    let mut result = String::new();
    if let Some((_brace, items)) = input.content {
        for item in &items {
            result.push_str(&metal_struct(item).unwrap());
        }
    }
    let expanded = quote! {
        fn #gen_metal_fn() {
            println!("{}", #result);
        }
    };
    expanded.into()
}

#[proc_macro_derive(PietMetal)]
pub fn derive_piet_metal(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as syn::DeriveInput);
    derive_proc_metal_impl(input)
        .unwrap_or_else(|err| err.to_compile_error())
        .into()
}

fn derive_proc_metal_impl(input: syn::DeriveInput) -> Result<proc_macro2::TokenStream, syn::Error> {
    println!("input: {:#?}", input);
    match &input.data {
        Data::Struct { .. } => {
            println!("it's a struct!");
        }
        _ => (),
    }
    let s = "this is a string";
    let expanded = quote! {
        fn foo() {
            println!("this was generated by proc macro: {}", #s);
        }
    };
    Ok(expanded)
    //Err(syn::Error::new(input.span(), "not yet implemented"))
}

impl Parse for Items {
    fn parse(input: ParseStream) -> Result<Self, syn::Error> {
        let mut items = Vec::new();
        while !input.is_empty() {
            items.push(input.parse()?)
        }
        Ok(Items(items))
    }
}
